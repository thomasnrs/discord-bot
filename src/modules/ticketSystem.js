const { EmbedBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle, PermissionFlagsBits, ChannelType, StringSelectMenuBuilder, StringSelectMenuOptionBuilder } = require('discord.js');

class TicketSystem {
    constructor() {
        this.ticketCategoryId = '1426614509069533306'; // Categoria espec√≠fica para tickets
        this.ticketPanelChannelId = null; // Ser√° definido quando criar o canal
        this.adminRoleId = '1404206347041505461'; // Cargo de admin
        this.autoCloseTime = parseInt(process.env.TICKET_AUTO_CLOSE_TIME) || 600000; // 10 minutos
        this.tickets = new Map(); // Armazenar informa√ß√µes dos tickets
        this.ticketCounter = 0; // Contador de tickets
        this.ticketLogs = new Map(); // Logs dos tickets
    }

    // Inicializar sistema de tickets
    init(client) {
        this.client = client;
        console.log('üé´ Sistema de tickets inicializado');
        
        // Criar canal de painel se n√£o existir
        this.createTicketPanel();
    }

    // Criar canal de painel de tickets
    async createTicketPanel() {
        try {
            const guild = this.client.guilds.cache.get(process.env.GUILD_ID);
            if (!guild) {
                console.log('‚ùå Servidor n√£o encontrado para criar painel de tickets');
                return;
            }

            // Buscar categoria de tickets
            const category = guild.channels.cache.get(this.ticketCategoryId);
            if (!category) {
                console.log('‚ùå Categoria de tickets n√£o encontrada');
                return;
            }

            // Verificar se j√° existe canal de painel
            const existingPanel = category.children.cache.find(channel => 
                channel.name.includes('painel-tickets') || 
                channel.name.includes('ticket-panel')
            );

            if (existingPanel) {
                this.ticketPanelChannelId = existingPanel.id;
                console.log('üìã Canal de painel de tickets j√° existe');
                return;
            }

            // Criar canal de painel
            const panelChannel = await guild.channels.create({
                name: 'üé´-painel-tickets',
                type: ChannelType.GuildText,
                parent: category.id,
                permissionOverwrites: [
                    {
                        id: guild.roles.everyone.id,
                        allow: [
                            PermissionFlagsBits.ViewChannel,
                            PermissionFlagsBits.ReadMessageHistory
                        ],
                        deny: [PermissionFlagsBits.SendMessages]
                    },
                    {
                        id: this.adminRoleId,
                        allow: [
                            PermissionFlagsBits.ViewChannel,
                            PermissionFlagsBits.SendMessages,
                            PermissionFlagsBits.ReadMessageHistory,
                            PermissionFlagsBits.ManageMessages
                        ]
                    }
                ]
            });

            this.ticketPanelChannelId = panelChannel.id;

            // Enviar painel de tickets
            await this.sendTicketPanel(panelChannel);
            console.log('üìã Painel de tickets criado');

        } catch (error) {
            console.error('‚ùå Erro ao criar painel de tickets:', error);
        }
    }

    // Enviar painel de tickets
    async sendTicketPanel(channel) {
        const embed = this.createTicketPanelEmbed();
        const row = this.createTicketPanelButtons();

        await channel.send({ 
            embeds: [embed], 
            components: [row] 
        });
    }

    // Criar embed do painel de tickets
    createTicketPanelEmbed() {
        return new EmbedBuilder()
            .setColor('#7289da')
            .setTitle('üé´ Sistema de Tickets - Nebula Friends')
            .setDescription(`
**Bem-vindo ao sistema de tickets!** üåü

Aqui voc√™ pode criar um ticket para receber suporte da nossa equipe.

**üìã Como usar:**
‚Ä¢ Clique no bot√£o **"Abrir Ticket"** abaixo
‚Ä¢ Escolha a categoria do seu problema
‚Ä¢ Descreva detalhadamente sua quest√£o
‚Ä¢ Aguarde um administrador responder

**üéØ Categorias dispon√≠veis:**
‚Ä¢ **üêõ Bug Report** - Reportar problemas t√©cnicos
‚Ä¢ **üí° Sugest√£o** - Sugerir melhorias
‚Ä¢ **‚ùì D√∫vida** - Tirar d√∫vidas gerais
‚Ä¢ **üö® Den√∫ncia** - Reportar comportamentos inadequados
‚Ä¢ **üîß Suporte** - Suporte t√©cnico
‚Ä¢ **üí∞ Economia** - Problemas com sistema de economia
‚Ä¢ **üéµ M√∫sica** - Problemas com sistema de m√∫sica
‚Ä¢ **üé´ Outros** - Outras quest√µes

**‚ö†Ô∏è Regras importantes:**
‚Ä¢ Seja respeitoso com a equipe
‚Ä¢ Descreva seu problema de forma clara
‚Ä¢ N√£o abuse do sistema de tickets
‚Ä¢ Aguarde a resposta da equipe
            `)
            .addFields(
                { name: 'üë• Equipe', value: 'Administradores e Staff', inline: true },
                { name: '‚è∞ Resposta', value: 'At√© 24 horas', inline: true },
                { name: 'üìû Status', value: 'üü¢ Online', inline: true }
            )
            .setThumbnail('https://cdn.discordapp.com/emojis/1234567890123456789.png')
            .setFooter({ 
                text: 'Nebula Friends ‚Ä¢ Sistema de Tickets',
                iconURL: this.client.user?.displayAvatarURL()
            })
            .setTimestamp();
    }

    // Criar bot√µes do painel de tickets
    createTicketPanelButtons() {
        return new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('open_ticket')
                    .setLabel('üé´ Abrir Ticket')
                    .setStyle(ButtonStyle.Primary)
                    .setEmoji('üé´')
            );
    }

    // Criar menu de sele√ß√£o de categoria
    createCategorySelectMenu() {
        return new StringSelectMenuBuilder()
            .setCustomId('ticket_category')
            .setPlaceholder('Escolha a categoria do seu ticket')
            .addOptions([
                new StringSelectMenuOptionBuilder()
                    .setLabel('üêõ Bug Report')
                    .setDescription('Reportar problemas t√©cnicos')
                    .setValue('bug')
                    .setEmoji('üêõ'),
                new StringSelectMenuOptionBuilder()
                    .setLabel('üí° Sugest√£o')
                    .setDescription('Sugerir melhorias')
                    .setValue('suggestion')
                    .setEmoji('üí°'),
                new StringSelectMenuOptionBuilder()
                    .setLabel('‚ùì D√∫vida')
                    .setDescription('Tirar d√∫vidas gerais')
                    .setValue('question')
                    .setEmoji('‚ùì'),
                new StringSelectMenuOptionBuilder()
                    .setLabel('üö® Den√∫ncia')
                    .setDescription('Reportar comportamentos inadequados')
                    .setValue('report')
                    .setEmoji('üö®'),
                new StringSelectMenuOptionBuilder()
                    .setLabel('üîß Suporte')
                    .setDescription('Suporte t√©cnico')
                    .setValue('support')
                    .setEmoji('üîß'),
                new StringSelectMenuOptionBuilder()
                    .setLabel('üí∞ Economia')
                    .setDescription('Problemas com sistema de economia')
                    .setValue('economy')
                    .setEmoji('üí∞'),
                new StringSelectMenuOptionBuilder()
                    .setLabel('üéµ M√∫sica')
                    .setDescription('Problemas com sistema de m√∫sica')
                    .setValue('music')
                    .setEmoji('üéµ'),
                new StringSelectMenuOptionBuilder()
                    .setLabel('üé´ Outros')
                    .setDescription('Outras quest√µes')
                    .setValue('other')
                    .setEmoji('üé´')
            ]);
    }

    // Criar ticket
    async createTicket(interaction, category, reason = 'Sem motivo especificado') {
        const guild = interaction.guild;
        const user = interaction.user;
        
        // Incrementar contador
        this.ticketCounter++;
        const ticketNumber = this.ticketCounter.toString().padStart(4, '0');

        // Buscar categoria de tickets
        const ticketCategory = guild.channels.cache.get(this.ticketCategoryId);
        if (!ticketCategory) {
            return {
                success: false,
                message: '‚ùå Categoria de tickets n√£o encontrada!'
            };
        }

        // Verificar se usu√°rio j√° tem ticket aberto
        const existingTicket = Array.from(this.tickets.values()).find(ticket => 
            ticket.userId === user.id && ticket.status === 'open'
        );

        if (existingTicket) {
            return {
                success: false,
                message: `‚ùå Voc√™ j√° tem um ticket aberto: <#${existingTicket.channelId}>`
            };
        }

        // Criar canal do ticket
        const ticketChannel = await guild.channels.create({
            name: `ticket-${ticketNumber}-${user.username}`,
            type: ChannelType.GuildText,
            parent: ticketCategory.id,
            topic: `Ticket #${ticketNumber} - ${user.tag} - ${category}`,
            permissionOverwrites: [
                {
                    id: guild.roles.everyone.id,
                    deny: [PermissionFlagsBits.ViewChannel]
                },
                {
                    id: user.id,
                    allow: [
                        PermissionFlagsBits.ViewChannel,
                        PermissionFlagsBits.SendMessages,
                        PermissionFlagsBits.ReadMessageHistory,
                        PermissionFlagsBits.AttachFiles,
                        PermissionFlagsBits.EmbedLinks
                    ]
                },
                {
                    id: this.adminRoleId,
                    allow: [
                        PermissionFlagsBits.ViewChannel,
                        PermissionFlagsBits.SendMessages,
                        PermissionFlagsBits.ReadMessageHistory,
                        PermissionFlagsBits.ManageMessages,
                        PermissionFlagsBits.AttachFiles,
                        PermissionFlagsBits.EmbedLinks
                    ]
                },
                {
                    id: guild.members.me.id,
                    allow: [
                        PermissionFlagsBits.ViewChannel,
                        PermissionFlagsBits.SendMessages,
                        PermissionFlagsBits.ReadMessageHistory,
                        PermissionFlagsBits.ManageMessages,
                        PermissionFlagsBits.AttachFiles,
                        PermissionFlagsBits.EmbedLinks
                    ]
                }
            ]
        });

        // Criar embed do ticket
        const embed = this.createTicketEmbed(user, category, reason, ticketNumber);
        const controlRow = this.createTicketControlButtons();

        await ticketChannel.send({ 
            content: `${user} | <@&${this.adminRoleId}>`,
            embeds: [embed],
            components: [controlRow]
        });

        // Salvar ticket
        const ticketId = `ticket_${Date.now()}`;
        this.tickets.set(ticketId, {
            id: ticketId,
            channelId: ticketChannel.id,
            userId: user.id,
            category: category,
            reason: reason,
            ticketNumber: ticketNumber,
            createdAt: Date.now(),
            status: 'open',
            logs: []
        });

        // Log da cria√ß√£o
        this.addTicketLog(ticketId, 'created', user.id, 'Ticket criado');

        return {
            success: true,
            channel: ticketChannel,
            ticketNumber: ticketNumber
        };
    }

    // Criar embed do ticket
    createTicketEmbed(user, category, reason, ticketNumber) {
        const categoryEmojis = {
            'bug': 'üêõ',
            'suggestion': 'üí°',
            'question': '‚ùì',
            'report': 'üö®',
            'support': 'üîß',
            'economy': 'üí∞',
            'music': 'üéµ',
            'other': 'üé´'
        };

        const categoryNames = {
            'bug': 'Bug Report',
            'suggestion': 'Sugest√£o',
            'question': 'D√∫vida',
            'report': 'Den√∫ncia',
            'support': 'Suporte',
            'economy': 'Economia',
            'music': 'M√∫sica',
            'other': 'Outros'
        };

        return new EmbedBuilder()
            .setColor('#00ff88')
            .setTitle(`üé´ Ticket #${ticketNumber} - ${categoryEmojis[category]} ${categoryNames[category]}`)
            .setDescription(`
**Ticket criado com sucesso!**

**üë§ Usu√°rio:** ${user}
**üìù Categoria:** ${categoryEmojis[category]} ${categoryNames[category]}
**üìÑ Motivo:** ${reason}
**‚è∞ Criado em:** <t:${Math.floor(Date.now() / 1000)}:F>
**üÜî ID do Ticket:** \`${ticketNumber}\`

**üìã Instru√ß√µes:**
‚Ä¢ Descreva seu problema de forma detalhada
‚Ä¢ Anexe imagens se necess√°rio
‚Ä¢ Aguarde a resposta da equipe
‚Ä¢ Use os bot√µes abaixo para gerenciar o ticket
            `)
            .addFields(
                { name: 'üîß Controles', value: 'Use os bot√µes abaixo para gerenciar o ticket', inline: false },
                { name: 'üë• Equipe', value: `<@&${this.adminRoleId}>`, inline: true },
                { name: 'üìä Status', value: 'üü¢ Aberto', inline: true }
            )
            .setThumbnail(user.displayAvatarURL())
            .setFooter({ 
                text: 'Nebula Friends ‚Ä¢ Sistema de Tickets',
                iconURL: this.client.user?.displayAvatarURL()
            })
            .setTimestamp();
    }

    // Criar bot√µes de controle do ticket
    createTicketControlButtons() {
        return new ActionRowBuilder()
            .addComponents(
                new ButtonBuilder()
                    .setCustomId('ticket_pause')
                    .setLabel('‚è∏Ô∏è Pausar')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('‚è∏Ô∏è'),
                new ButtonBuilder()
                    .setCustomId('ticket_log')
                    .setLabel('üìã Logs')
                    .setStyle(ButtonStyle.Secondary)
                    .setEmoji('üìã'),
                new ButtonBuilder()
                    .setCustomId('ticket_close')
                    .setLabel('üîí Fechar')
                    .setStyle(ButtonStyle.Danger)
                    .setEmoji('üîí')
            );
    }

    // Pausar ticket
    async pauseTicket(interaction) {
        const channel = interaction.channel;
        const user = interaction.user;
        
        // Verificar se √© um canal de ticket
        if (!channel.name.startsWith('ticket-')) {
            return {
                success: false,
                message: '‚ùå Este n√£o √© um canal de ticket!'
            };
        }

        // Verificar permiss√µes
        if (!interaction.member.roles.cache.has(this.adminRoleId) && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return {
                success: false,
                message: '‚ùå Voc√™ n√£o tem permiss√£o para pausar tickets!'
            };
        }

        // Buscar ticket
        const ticket = Array.from(this.tickets.values()).find(t => t.channelId === channel.id);
        if (!ticket) {
            return {
                success: false,
                message: '‚ùå Ticket n√£o encontrado!'
            };
        }

        // Atualizar status
        ticket.status = 'paused';
        ticket.pausedAt = Date.now();
        ticket.pausedBy = user.id;

        // Log da pausa
        this.addTicketLog(ticket.id, 'paused', user.id, 'Ticket pausado');

        // Atualizar permiss√µes (remover permiss√£o de enviar mensagens do usu√°rio)
        const ticketUser = interaction.guild.members.cache.get(ticket.userId);
        if (ticketUser) {
            await channel.permissionOverwrites.edit(ticketUser, {
                SendMessages: false
            });
        }

        const embed = new EmbedBuilder()
            .setColor('#ff8800')
            .setTitle('‚è∏Ô∏è Ticket Pausado')
            .setDescription(`Ticket pausado por ${user}`)
            .addFields(
                { name: 'üë§ Pausado por', value: user.toString(), inline: true },
                { name: '‚è∞ Pausado em', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true },
                { name: 'üìä Status', value: 'üü° Pausado', inline: true }
            )
            .setTimestamp();

        await channel.send({ embeds: [embed] });

        return {
            success: true,
            message: '‚úÖ Ticket pausado! O usu√°rio n√£o pode mais enviar mensagens.'
        };
    }

    // Retomar ticket
    async resumeTicket(interaction) {
        const channel = interaction.channel;
        const user = interaction.user;
        
        // Verificar se √© um canal de ticket
        if (!channel.name.startsWith('ticket-')) {
            return {
                success: false,
                message: '‚ùå Este n√£o √© um canal de ticket!'
            };
        }

        // Verificar permiss√µes
        if (!interaction.member.roles.cache.has(this.adminRoleId) && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return {
                success: false,
                message: '‚ùå Voc√™ n√£o tem permiss√£o para retomar tickets!'
            };
        }

        // Buscar ticket
        const ticket = Array.from(this.tickets.values()).find(t => t.channelId === channel.id);
        if (!ticket) {
            return {
                success: false,
                message: '‚ùå Ticket n√£o encontrado!'
            };
        }

        // Atualizar status
        ticket.status = 'open';
        ticket.resumedAt = Date.now();
        ticket.resumedBy = user.id;

        // Log da retomada
        this.addTicketLog(ticket.id, 'resumed', user.id, 'Ticket retomado');

        // Restaurar permiss√µes
        const ticketUser = interaction.guild.members.cache.get(ticket.userId);
        if (ticketUser) {
            await channel.permissionOverwrites.edit(ticketUser, {
                SendMessages: true
            });
        }

        const embed = new EmbedBuilder()
            .setColor('#00ff88')
            .setTitle('‚ñ∂Ô∏è Ticket Retomado')
            .setDescription(`Ticket retomado por ${user}`)
            .addFields(
                { name: 'üë§ Retomado por', value: user.toString(), inline: true },
                { name: '‚è∞ Retomado em', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true },
                { name: 'üìä Status', value: 'üü¢ Aberto', inline: true }
            )
            .setTimestamp();

        await channel.send({ embeds: [embed] });

        return {
            success: true,
            message: '‚úÖ Ticket retomado! O usu√°rio pode enviar mensagens novamente.'
        };
    }

    // Fechar ticket
    async closeTicket(interaction) {
        const channel = interaction.channel;
        const user = interaction.user;
        
        // Verificar se √© um canal de ticket
        if (!channel.name.startsWith('ticket-')) {
            return {
                success: false,
                message: '‚ùå Este n√£o √© um canal de ticket!'
            };
        }

        // Verificar permiss√µes
        if (!interaction.member.roles.cache.has(this.adminRoleId) && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return {
                success: false,
                message: '‚ùå Voc√™ n√£o tem permiss√£o para fechar tickets!'
            };
        }

        // Buscar ticket
        const ticket = Array.from(this.tickets.values()).find(t => t.channelId === channel.id);
        if (!ticket) {
            return {
                success: false,
                message: '‚ùå Ticket n√£o encontrado!'
            };
        }

        // Atualizar status
        ticket.status = 'closed';
        ticket.closedAt = Date.now();
        ticket.closedBy = user.id;

        // Log do fechamento
        this.addTicketLog(ticket.id, 'closed', user.id, 'Ticket fechado');

        // Criar embed de fechamento
        const embed = new EmbedBuilder()
            .setColor('#ff4444')
            .setTitle('üîí Ticket Fechado')
            .setDescription(`Ticket #${ticket.ticketNumber} foi fechado`)
            .addFields(
                { name: 'üë§ Fechado por', value: user.toString(), inline: true },
                { name: '‚è∞ Fechado em', value: `<t:${Math.floor(Date.now() / 1000)}:F>`, inline: true },
                { name: 'üìä Status', value: 'üî¥ Fechado', inline: true }
            )
            .setTimestamp();

        await channel.send({ embeds: [embed] });

        // Renomear canal
        await channel.setName(`closed-${channel.name}`);

        // Deletar canal ap√≥s 30 segundos
        setTimeout(async () => {
            try {
                await channel.delete();
            } catch (error) {
                console.error('‚ùå Erro ao deletar canal de ticket:', error);
            }
        }, 30000);

        return {
            success: true,
            message: '‚úÖ Ticket fechado! O canal ser√° deletado em 30 segundos.'
        };
    }

    // Mostrar logs do ticket
    async showTicketLogs(interaction) {
        const channel = interaction.channel;
        
        // Verificar se √© um canal de ticket
        if (!channel.name.startsWith('ticket-')) {
            return {
                success: false,
                message: '‚ùå Este n√£o √© um canal de ticket!'
            };
        }

        // Verificar permiss√µes
        if (!interaction.member.roles.cache.has(this.adminRoleId) && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return {
                success: false,
                message: '‚ùå Voc√™ n√£o tem permiss√£o para ver logs de tickets!'
            };
        }

        // Buscar ticket
        const ticket = Array.from(this.tickets.values()).find(t => t.channelId === channel.id);
        if (!ticket) {
            return {
                success: false,
                message: '‚ùå Ticket n√£o encontrado!'
            };
        }

        // Criar embed de logs
        const logs = ticket.logs || [];
        const logText = logs.length > 0 ? 
            logs.map(log => `**${log.action}** - <t:${Math.floor(log.timestamp / 1000)}:R> - <@${log.userId}>`).join('\n') :
            'Nenhum log encontrado';

        const embed = new EmbedBuilder()
            .setColor('#0099ff')
            .setTitle(`üìã Logs do Ticket #${ticket.ticketNumber}`)
            .setDescription(logText)
            .addFields(
                { name: 'üìä Informa√ß√µes', value: `**Status:** ${ticket.status}\n**Criado:** <t:${Math.floor(ticket.createdAt / 1000)}:R>\n**Usu√°rio:** <@${ticket.userId}>`, inline: false }
            )
            .setTimestamp();

        await interaction.reply({ embeds: [embed], ephemeral: true });

        return {
            success: true,
            message: 'üìã Logs exibidos!'
        };
    }

    // Adicionar log ao ticket
    addTicketLog(ticketId, action, userId, description) {
        const ticket = this.tickets.get(ticketId);
        if (ticket) {
            if (!ticket.logs) ticket.logs = [];
            ticket.logs.push({
                action: action,
                userId: userId,
                description: description,
                timestamp: Date.now()
            });
        }
    }

    // Adicionar usu√°rio ao ticket
    async addUser(interaction, user) {
        const channel = interaction.channel;
        
        // Verificar se √© um canal de ticket
        if (!channel.name.startsWith('ticket-') && !channel.name.startsWith('closed-')) {
            return {
                success: false,
                message: '‚ùå Este n√£o √© um canal de ticket!'
            };
        }

        // Verificar permiss√µes
        if (!interaction.member.roles.cache.has(this.adminRoleId) && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return {
                success: false,
                message: '‚ùå Voc√™ n√£o tem permiss√£o para adicionar usu√°rios!'
            };
        }

        // Adicionar usu√°rio ao ticket
        await channel.permissionOverwrites.create(user, {
            ViewChannel: true,
            SendMessages: true,
            ReadMessageHistory: true,
            AttachFiles: true,
            EmbedLinks: true
        });

        return {
            success: true,
            message: `‚úÖ ${user} foi adicionado ao ticket!`
        };
    }

    // Remover usu√°rio do ticket
    async removeUser(interaction, user) {
        const channel = interaction.channel;
        
        // Verificar se √© um canal de ticket
        if (!channel.name.startsWith('ticket-') && !channel.name.startsWith('closed-')) {
            return {
                success: false,
                message: '‚ùå Este n√£o √© um canal de ticket!'
            };
        }

        // Verificar permiss√µes
        if (!interaction.member.roles.cache.has(this.adminRoleId) && !interaction.member.permissions.has(PermissionFlagsBits.Administrator)) {
            return {
                success: false,
                message: '‚ùå Voc√™ n√£o tem permiss√£o para remover usu√°rios!'
            };
        }

        // Remover usu√°rio do ticket
        await channel.permissionOverwrites.delete(user);

        return {
            success: true,
            message: `‚úÖ ${user} foi removido do ticket!`
        };
    }

    // Obter estat√≠sticas do sistema
    getStats() {
        const openTickets = Array.from(this.tickets.values()).filter(t => t.status === 'open').length;
        const pausedTickets = Array.from(this.tickets.values()).filter(t => t.status === 'paused').length;
        const closedTickets = Array.from(this.tickets.values()).filter(t => t.status === 'closed').length;
        const totalTickets = this.tickets.size;

        return {
            total: totalTickets,
            open: openTickets,
            paused: pausedTickets,
            closed: closedTickets,
            categoryId: this.ticketCategoryId,
            panelChannelId: this.ticketPanelChannelId,
            adminRoleId: this.adminRoleId
        };
    }
}

module.exports = TicketSystem;